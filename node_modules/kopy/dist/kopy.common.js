'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var path = _interopDefault(require('path'));
var Metalsmith = _interopDefault(require('metalsmith'));
var match = _interopDefault(require('minimatch'));
var inquirer = _interopDefault(require('inquirer'));
var asyncEach = _interopDefault(require('async.each'));
var match$1 = _interopDefault(require('multimatch'));
var isBinaryPath = _interopDefault(require('is-binary-path'));
var exists = _interopDefault(require('path-exists'));

// forked from https://github.com/vuejs/vue-cli/blob/master/lib/eval.js

function evalualte(exp, data) {
  /* eslint-disable no-new-func */
  var fn = new Function('data', 'with (data) { return ' + exp + ' }');
  try {
    return fn(data);
  } catch (err) {
    console.error('Error when evaluating filter condition: ' + exp);
  }
}

// forked from https://github.com/vuejs/vue-cli/blob/master/lib/filter.js
function filter(files, filters, data, done) {
  if (!filters) {
    return done();
  }
  var fileNames = Object.keys(files);
  Object.keys(filters).forEach(function (glob) {
    fileNames.forEach(function (file) {
      if (match(file, glob, { dot: true })) {
        var condition = filters[glob];
        if (!evalualte(condition, data)) {
          delete files[file];
        }
      }
    });
  });
  done();
}

function filterFiles(filters) {
  return function (files, metalsmith, done) {
    filter(files, filters, metalsmith.metadata().merged, done);
  };
}

function ask(data, prompts) {
  return function (files, metalsmith, done) {
    if (prompts) {
      inquirer.prompt(prompts).then(function (answers) {
        var merged = Object.assign({}, data, answers);

        // prevent from ReferenceErrors
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = prompts[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var prompt = _step.value;

            if (!Object.prototype.hasOwnProperty.call(merged, prompt.name)) {
              merged[prompt.name] = undefined;
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        metalsmith.metadata({ data: data, answers: answers, merged: merged });
        done();
      }).catch(done);
    } else if (data) {
      metalsmith.metadata({ data: data, merged: data });
      done();
    } else {
      metalsmith.metadata({ merged: {} });
      done();
    }
  };
}

var useTemplate = (function () {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      skipInterpolation = _ref.skipInterpolation,
      _ref$template = _ref.template,
      template = _ref$template === undefined ? require('jstransformer-ejs') : _ref$template,
      _ref$templateOptions = _ref.templateOptions,
      templateOptions = _ref$templateOptions === undefined ? {} : _ref$templateOptions;

  return function (files, metalsmith, done) {
    var keys = Object.keys(files);
    var matchedFile = void 0;
    if (skipInterpolation) {
      if (typeof skipInterpolation === 'function') {
        matchedFile = skipInterpolation;
      } else {
        (function () {
          var matches = match$1(keys, skipInterpolation);
          matchedFile = function matchedFile(file) {
            return matches.indexOf(file) !== -1;
          };
        })();
      }
    }

    asyncEach(keys, run, done);

    function run(file, done) {
      var content = files[file].contents.toString();

      var shouldSkip = matchedFile && matchedFile(file, content);

      // we skip unmathed files (by multimatch or your own function)
      // and binary files
      if (shouldSkip || isBinaryPath(file)) {
        return done();
      }

      var res = require('jstransformer')(template).render(content, templateOptions, metalsmith.metadata().merged);
      files[file].contents = new Buffer(res.body);
      done();
    }
  };
});

var skip = function (skipExisting, destPath) {
  return function (files, metalsmith, done) {
    Promise.all(Object.keys(files).map(function (name) {
      var location = path.join(destPath, name);
      return exists(location).then(function (yes) {
        if (yes) {
          delete files[name];
          if (typeof skipExisting === 'function') {
            skipExisting(location);
          }
        }
      });
    })).then(function () {
      return done();
    }).catch(done);
  };
};

var moveFiles = function (move) {
  return function (files, metalsmith, done) {
    if (!move) return done();

    for (var pattern in move) {
      var matches = match.match(Object.keys(files), pattern);
      if (matches.length > 0) {
        var content = files[matches[0]];
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = matches[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var match$$1 = _step.value;

            delete files[match$$1];
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        var newName = move[pattern];
        files[newName] = content;
      }
    }

    done();
  };
};

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function kopy(src, dest) {
  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      _ref$cwd = _ref.cwd,
      cwd = _ref$cwd === undefined ? process.cwd() : _ref$cwd,
      _ref$clean = _ref.clean,
      clean = _ref$clean === undefined ? false : _ref$clean,
      data = _ref.data,
      prompts = _ref.prompts,
      _ref$disableInterpola = _ref.disableInterpolation,
      disableInterpolation = _ref$disableInterpola === undefined ? false : _ref$disableInterpola,
      skipInterpolation = _ref.skipInterpolation,
      template = _ref.template,
      templateOptions = _ref.templateOptions,
      filters = _ref.filters,
      skipExisting = _ref.skipExisting,
      move = _ref.move;

  return new Promise(function (resolve, reject) {
    var source = path.resolve(cwd, src);
    var destPath = path.resolve(cwd, dest);
    var pipe = Metalsmith(source); // eslint-disable-line new-cap

    pipe.source('.').ignore(function (file) {
      return (/\.DS_Store$/.test(file)
      );
    }).use(ask(data, prompts)).use(filterFiles(filters)).use(moveFiles(move));

    if (!disableInterpolation) {
      pipe.use(useTemplate({ skipInterpolation: skipInterpolation, template: template, templateOptions: templateOptions }));
    }

    if (skipExisting) {
      pipe.use(skip(skipExisting, destPath));
    }

    pipe.clean(clean).destination(destPath).build(function (err, files) {
      if (err) return reject(err);
      resolve(_extends({
        files: Object.keys(files)
      }, pipe.metadata()));
    });
  });
}

module.exports = kopy;
